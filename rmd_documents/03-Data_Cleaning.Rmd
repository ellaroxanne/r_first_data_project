---
title: "Intro to R: Basic Summary Statistics"
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.eval = FALSE)
gradethis::gradethis_setup()
```

```{r}
raw_data <- read.csv("https://raw.githubusercontent.com/ellaroxanne/r_first_data_project/refs/heads/main/data_and_metadata/BLOY_morphology_AlaskaBC.csv")
```

Now that we vaguely know what our data's about, let's get a little more used to what it contains. 
Yay! We finally get to work with numbers!

[add a cute gif of someone celebrating]

# Preparing Your Data - Factors

R has a very helpful built in function, the <code> summary() </code> function, which provides a nice, quick glance at your data. 
To call it, call the <code> summary </code> function with your dataset as an argument.
Remember, our dataset as it is right now is labelled <code> raw_data </code>. 

```{r}
summary(raw_data)
```

What does the summary function do? What do you notice? 

<!-- Textbox -->

One important thing to notice is that the summary function treats <b> numerical </b> variables and <b> categorical </b> variables differently. 

What information does it display about the numerical variables? 

<!-- Defs of numerical and categorical can be placed in lesson 0 -->

<!-- Textbox -->

What information does it display about the categorical variables? 

<!-- Textbox -->

You may notice, the information it displays for categorical variables is somewhat limited. 
Since categorical variables are usually different ``buckets'' (check), think of a way we've learned to describe them.

That's right! Factors. 

Let's start by making the <code> Region </code> variable a factor. 

<!-- Progressive hints: as.factor() function
Arguments is the column
Index a column with $ -->

```{r}
raw_data$Region <- as.factor(raw_data$Region)
```

Now, let's take a look at how this changed the summary function:

```{r}
summary(raw_data)
```

How did the factor change the way the <code> summary </code> function worked with the categorical variables? 

<!-- Textbox -->

Let's do this for the rest of the categorical variables!

<!-- Maybe have a thing. Think about each variable: should it be a factor or not? Most of the character ones should, but alpha notably shouldn't. Somehow point the student in that direction and understand why.--> 
```{r}
raw_data$Site <- as.factor(raw_data$Site)
raw_data$Season <- as.factor(raw_data$Season)
raw_data$Age_class <- as.factor(raw_data$Age_class)
raw_data$Eye_fleck <- as.factor(raw_data$Eye_fleck)
raw_data$Sex <- as.factor(raw_data$Sex)
raw_data$Bander <- as.factor(raw_data$Bander)
```

Now that everything's a factor, let's try our summary function again:
```{r}
summary(raw_data)
```

# 1.5. Handling "Date" 

```{r}
raw_data$Date <- as.Date(raw_data$Date)
```

```{r}
summary(raw_data)
```

# Handling Structural Issues

`<!-- Perhaps have some inconsistencies in like, case or something. 
For example, some sexes are labelled F and some are female. How can we use R to put those all in the same factor?-->

<!-- This would involve artificial dirtying of the data -->

# Removing Duplicates

Now, we're ready to really clean our data. 
We've already done the sort of ``step 0'' of this in the previous section, where we familiarized ourselves with the metadata and ensured the data was accurate and collected properly. 

Now, we're going to make sure everything is in order on the numerical side. 

The first step we can do is check for duplicates! 

That is, we can make sure none of the observations were accidentally added twice. 

Because this is such a common problem in data analysis, R has a built in function called <code> duplicated() </code> which takes your dataset as an argument, and checks if any rows are duplicated. 

Try the function now:

```{r}
duplicated(raw_data)
```

What did the function return? A vector? What type?

<!-- Textbox -->

What has the function done? 
<!-- Textbox 
ANSWER: Iterated through the rows and checked if there are any duplicates of the previous rows.-->

<!-- Observation: This is what makes ALPHA and other primary keys important, because it ensures that if by some crazy coincidence, two entries had the exact same measurements, they wouldn't accidentally be counted as duplicates--> 

We've got a huge list that looks like it's all <code> FALSE </code> but let's make sure that there's no <code> TRUE </code> in there. 

The best practice to do this is the <code> which() </code> function. 
The <code> which() </code> function will tell you if there are any <code> TRUE </code> values in your vector, and what their indices are. 

<!-- Mention which function in lesson 0, or we can split that up -->

```{r}
which(duplicated(raw_data))
```

Since it returend <code> integer(0) </code>, that means that we have no duplicates! 

<!-- I have half a mind to falsely dirty the data and add a duplicate so we can practice removing them -->

# Handling Missing Values

Let's make sure our data is clean. First, we'll have the is.na() function. This checks for if there are any values missing. 

We can do this by columns. R has a built-in function called <code> colSums </code> that is made for this purpose. It basically sums by column.

```{r}
# colSums(raw_data)
```

This process is called <b> data cleaning </b>, and it's just a part of the data science process. 

Now we need to decide what to do with the missing values. 

There's a couple ways we can deal with this. 

The first, and arguably the most common way, is to basically just ignore them. 
Okay, that's perhaps a little flippant. 

But, we don't consider those data points in our analysis; we remove the rows. 

A helpful way of doing this is through R's built in <code> complete.cases() </code> function. 
This function finds all the rows that have no missing values. 

Let's try it now: 

<!-- interactive code box where user can type it themself-->

```{r}
# complete.cases(raw_data)
```

Any row marked <code> FALSE </code> is not a complete case-- meaning it has at least one missing value. 

The <code> complete.case() </code> function just tells you which rows do and do not have complete cases. 
In order to use it to remove the rows, we have to filter it. 

The way we do this is by using the Boolean mask to index. 

```{r}
# removed_rows_data <- raw_data[complete.cases(raw_data), ]
# print(removed_rows_data)
```

<!-- Go over indexing in 00 lesson-->

Great! Why would we need any other option? 
Well, let's compare the number of rows. 

```{r}
#print(nrow(raw_data))
#print(nrow(removed_rows_data))
```

We've deleted 40 data points! That has significantly impacted our sample size. 

For example, say we are trying to study the Wing variable. 

```{r}
#colSums(raw_data)
```
Only three specimens are missing Wing values. 10, however, are missing tail measurements. 

If we're only trying to study the Wing value, we've just throw out up to 7 perfectly good datapoints of Wing measurements, by removing all the rows!

This could also introduce bias, if the missing values were not randomly missing. 

<!-- Can o' worms ^ -->


