---
title: "Intro to R: Basic Summary Statistics"
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.eval = FALSE)
gradethis::gradethis_setup()
```

```{r}
raw_data <- read.csv("https://raw.githubusercontent.com/ellaroxanne/r_first_data_project/refs/heads/main/data_and_metadata/BLOY_morphology_AlaskaBC.csv")
```

Now that we vaguely know what our data's about, let's get a little more used to what it contains. 
Yay! We finally get to work with numbers!

[add a cute gif of someone celebrating]

# 1. Getting Your Data Ready with Factors

R has a very helpful built in function, the <code> summary() </code> function, which provides a nice, quick glance at your data. 
To call it, call the <code> summary </code> function with your dataset as an argument.
Remember, our dataset as it is right now is labelled <code> raw_data </code>. 

```{r}
summary(raw_data)
```

What does the summary function do? What do you notice? 

<!-- Textbox -->

One important thing to notice is that the summary function treats <b> numerical </b> variables and <b> categorical </b> variables differently. 

What information does it display about the numerical variables? 

<!-- Defs of numerical and categorical can be placed in lesson 0 -->

<!-- Textbox -->

What information does it display about the categorical variables? 

<!-- Textbox -->

You may notice, the information it displays for categorical variables is somewhat limited. 
Since categorical variables are usually different ``buckets'' (check), think of a way we've learned to describe them.

That's right! Factors. 

Let's start by making the <code> Region </code> variable a factor. 

<!-- Progressive hints: as.factor() function
Arguments is the column
Index a column with $ -->

```{r}
raw_data$Region <- as.factor(raw_data$Region)
```

Now, let's take a look at how this changed the summary function:

```{r}
summary(raw_data)
```

How did the factor change the way the <code> summary </code> function worked with the categorical variables? 

<!-- Textbox -->

Let's do this for the rest of the categorical variables!

<!-- Maybe have a thing. Think about each variable: should it be a factor or not? Most of the character ones should, but alpha notably shouldn't. Somehow point the student in that direction and understand why.--> 
```{r}
raw_data$Site <- as.factor(raw_data$Site)
raw_data$Season <- as.factor(raw_data$Season)
raw_data$Age_class <- as.factor(raw_data$Age_class)
raw_data$Eye_fleck <- as.factor(raw_data$Eye_fleck)
raw_data$Sex <- as.factor(raw_data$Sex)
raw_data$Bander <- as.factor(raw_data$Bander)
```

Now that everything's a factor, let's try our summary function again:
```{r}
summary(raw_data)
```

# 1.5. Handling "Date" 

```{r}
raw_data$Date <- as.Date(raw_data$Date)
```

```{r}
summary(raw_data)
```

# 2. Basic Data Cleaning

Try <code> duplicated() </code> function. 

```{r}
duplicated(raw_data)
```

Returns a bunch of falses. 
Easy for a truth to get lost in there!

<!-- Mention which function in lesson 0, or we can split that up -->

```{r}
which(duplicated(raw_data))
```
# 2. Cleaning the Categorical Data




# 3. Numerical -> imputing missing

Let's make sure our data is clean. First, we'll have the is.na() function. This checks for if there are any values missing. 

We can do this by columns. R has a built-in function called <code> colSums </code> that is made for this purpose. It basically sums by column.

```{r}
# colSums(raw_data)
```

This process is called <b> data cleaning </b>, and it's just a part of the data science process. 

Now we need to decide what to do with the missing values. 

There's a couple ways we can deal with this. 

The first, and arguably the most common way, is to basically just ignore them. 
Okay, that's perhaps a little flippant. 

But, we don't consider those data points in our analysis; we remove the rows. 

A helpful way of doing this is through R's built in <code> complete.cases() </code> function. 
This function finds all the rows that have no missing values. 

Let's try it now: 

<!-- interactive code box where user can type it themself-->

```{r}
# complete.cases(raw_data)
```

Any row marked <code> FALSE </code> is not a complete case-- meaning it has at least one missing value. 

The <code> complete.case() </code> function just tells you which rows do and do not have complete cases. 
In order to use it to remove the rows, we have to filter it. 

The way we do this is by using the Boolean mask to index. 

```{r}
# removed_rows_data <- raw_data[complete.cases(raw_data), ]
# print(removed_rows_data)
```

<!-- Go over indexing in 00 lesson-->

Great! Why would we need any other option? 
Well, let's compare the number of rows. 

```{r}
#print(nrow(raw_data))
#print(nrow(removed_rows_data))
```

We've deleted 40 data points! That has significantly impacted our sample size. 

For example, say we are trying to study the Wing variable. 

```{r}
#colSums(raw_data)
```
Only three specimens are missing Wing values. 10, however, are missing tail measurements. 

If we're only trying to study the Wing value, we've just throw out up to 7 perfectly good datapoints of Wing measurements, by removing all the rows!

This could also introduce bias, if the missing values were not randomly missing. 

<!-- Can o' worms ^ -->


